# Copyright (C) 2008 LibreSoft
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# Authors :
#       Israel Herraiz <herraiz@gsyc.escet.urjc.es>

# Description
# -----------
# This extension calculates some metrics for all the different
# versions of all the files stored in the control version system.
#
# It needs the FilePaths extension to be called first.

from repositoryhandler.backends import create_repository
from pycvsanaly2.Database import (SqliteDatabase, MysqlDatabase, TableAlreadyExists,
                                  statement, DBFile)
from pycvsanaly2.extensions import Extension, register_extension, ExtensionRunError
from pycvsanaly2.utils import printdbg, printerr
from tempfile import mkdtemp
import os
import commands


class Measures:

    def __init__ (self):
        self.__dict__ = {
            'lang'           : 'unknown',
            'loc'            : None,
            'sloc'           : None,
            'ncomment'       : None,
            'lcomment'       : None,
            'lblank'         : None,
            'nfunctions'     : None,
            'mccabe_max'     : None,
            'mccabe_min'     : None,
            'mccabe_sum'     : None,
            'mccabe_mean'    : None,
            'mccabe_median'  : None,
            'halstead_length': None,
            'halstead_vol'   : None,
            'halstead_level' : None,
            'halstead_md'    : None,
        }

    def __getattr__ (self, name):
        return self.__dict__[name]

    def __setattr__ (self, name, value):
        self.__dict__[name] = value

    def getattrs (self):
        return self.__dict__.keys ()

class FileMetrics:

    def __init__ (self, path, lang='unknown', sloc=0):
        self.path = path
        self.lang = lang
        self.sloc = sloc
    
    def get_LOC (self):
        """Measures LOC using Python file functions"""
        
        fileobj = open (self.path, 'r')
        loc = len (fileobj.readlines ())
        fileobj.close ()
        
        return loc

    def get_SLOCLang (self):
        return self.sloc, self.lang

    def get_CommentsBlank (self):
        raise NotImplementedError

    def get_HalsteadComplexity (self):
        raise NotImplementedError

    def get_MccabeComplexity (self):
        raise NotImplementedError

class FileMetricsC (FileMetrics):
    """Measures McCabe's complexity, Halstead's complexity,
    comment and blank lines, using the 'metrics' package by Brian
    Renaud, stored in the Libresoft's subversion repository."""
    
    def get_CommentsBlank (self):
        # Running kdsi
        kdsicmd = "kdsi " + self.path
        outputtext = commands.getoutput (kdsicmd)
        # Get rid of all the spaces and get a list
        output_values = [x for x in outputtext.split (' ') if '' != x]
        # sloc will be ignored, but it is also generated by the tool
        dummy, blank_lines, comment_lines, comment_number, dummy = output_values

        return comment_number, comment_lines, blank_lines

    def get_HalsteadComplexity (self):
        # Running halstead
        halsteadcmd = "halstead " + self.path
        outputtext = commands.getoutput (halsteadcmd)
        values = outputtext.split ('\t')

        filename = values[0]
        halstead_length = int (values[1])
        halstead_volume = int (values[2])
        halstead_level = float (values[3].replace (',', '.'))
        halstead_md = int (values[4])

        return halstead_length, halstead_volume, halstead_level, halstead_md

    def get_MccabeComplexity (self):
        # Running mccabe
        mccabecmd = "mccabe -n " + self.path
        # The output of this tool is multiline (one line per function)
        outputlines = commands.getoutput (mccabecmd).split ('\n')
        mccabe_values = []
        nfunctions = 0
        mccabe_sum = mccabe_min = mccabe_max = mccabe_mean = mccabe_median = None
        for l in outputlines:
            values = l.split ('\t')
            if len (values) != 5:
                continue
            
            mccabe = int (values[-2])
            nfunctions += 1
            mccabe_values.append (mccabe)

        # There is a mccabe value for each function
        # This calculates some summary statistics for that set of
        # values
        if mccabe_values:
            mccabe_sum = sum (mccabe_values)
            if nfunctions >= 1:
                mccabe_mean = mccabe_sum / nfunctions
            
            mccabe_min = min (mccabe_values)
            mccabe_max = max (mccabe_values)

            # Calculate median
            mccabe_values.sort ()
            if nfunctions == 1:
                mccabe_median = mccabe_mean
            elif nfunctions >= 2:
                n = len (mccabe_values)
                if nfunctions & 1:
                    mccabe_median = mccabe_values[n // 2]
                else:
                    mccabe_median = (mccabe_values[n // 2 - 1] + mccabe_values[n // 2]) / 2
        else:
            nfunctions = None
            
        return mccabe_sum, mccabe_min, mccabe_max, mccabe_mean, mccabe_median, nfunctions
                
    
_metrics = {
    "unknown" : FileMetrics,
    "ansic"   : FileMetricsC
}
    
def create_file_metrics (path):
    """Measures SLOC and identifies programming language using SlocCount"""

    sloccountcmd = 'sloccount --wide --details ' + path
    outputlines = commands.getoutput (sloccountcmd).split ('\n')

    sloc = 0
    lang = 'unknown'
    for l in outputlines:
        # If there is not 'top_dir', then ignore line
        if '\ttop_dir\t' in l:
            sloc, lang, unused1, unused2 = l.split ('\t')

        # If no line with 'top_dir' is found, that means
        # that SLOC is 0 and lang is unknown
        
    fm = _metrics.get (lang, FileMetrics)
    return fm (path, lang, sloc);
        
class Metrics (Extension):

    deps = ['FilePaths']

    def __init__ (self):
        self.db = None
    
    def __create_table (self, cnn):
        cursor = cnn.cursor ()

        if isinstance (self.db, SqliteDatabase):
            import pysqlite2.dbapi2
            
            try:
                cursor.execute ("CREATE TABLE metrics (" +
                                "id integer primary key," +
                                "file_id integer," +
                                "commit_id integer," +
                                "lang text," +
                                "sloc integer," +
                                "loc integer," +
                                "ncomment integer," +
                                "lcomment integer," +
                                "lblank integer," +
                                "nfunctions integer," +
                                "mccabe_max integer," +
                                "mccabe_min integer," +
                                "mccabe_sum integer," +
                                "mccabe_mean integer," +
                                "mccabe_median integer," +
                                "halstead_length integer,"+
                                "halstead_vol integer," +
                                "halstead_level double,"+
                                "halstead_md integer" +
                                ")")
            except pysqlite2.dbapi2.OperationalError:
                raise TableAlreadyExists
            except:
                raise
        elif isinstance (self.db, MysqlDatabase):
            import _mysql_exceptions

            try:
                cursor.execute ("CREATE TABLE metrics (" +
                                "id integer primary key not null auto_increment," +
                                "file_id integer," +
                                "commit_id integer," +
                                "lang tinytext," +
                                "sloc integer," +
                                "loc integer," +
                                "ncomment integer," +
                                "lcomment integer," +
                                "lblank integer," +
                                "nfunctions integer," +
                                "mccabe_max integer," +
                                "mccabe_min integer," +
                                "mccabe_sum integer," +
                                "mccabe_mean integer," +
                                "mccabe_median integer," +
                                "halstead_length integer,"+
                                "halstead_vol integer," +
                                "halstead_level double,"+
                                "halstead_md integer," +
                                "FOREIGN KEY (file_id) REFERENCES tree(id)," +
                                "FOREIGN KEY (commit_id) REFERENCES scmlog(id)" +
                                ") CHARACTER SET=utf8")
            except _mysql_exceptions.OperationalError, e:
                if e.args[0] == 1050:
                    raise TableAlreadyExists
                raise
            except:
                raise
            
        cnn.commit ()
        cursor.close ()

    def run (self, repo, db):
        self.db = db

        cnn = self.db.connect()

        try:
            self.__create_table (cnn)
        except TableAlreadyExists:
            # Do something
            pass
        except Exception, e:
            raise ExtensionRunError (str(e))

        read_cursor = cnn.cursor()
        write_cursor = cnn.cursor()

        repobj = None
        repoid = -1
        uri = None
        
        # Obtain repository data and create repo object
        query = 'SELECT id, uri, type FROM repositories'
        read_cursor.execute (statement (query, db.place_holder))
        
        # Analyze all the repos contained in the db
        for repoid, uri, type in read_cursor.fetchall ():
            repobj = create_repository (type, uri)

            # Temp dir for the checkouts
            tmpdir = mkdtemp ()
            
            # SVN needs the first revision
            if type == 'svn':
                query = 'SELECT MIN(rev) FROM scmlog'
                read_cursor.execute (statement (query, db.place_holder))
                first_rev = read_cursor.fetchone()[0]
                
                try:
                    repobj.checkout ('.', tmpdir, newdir='.', rev=first_rev)
                except Exception, e:
                    msg = 'SVN checkout first rev (%s) failed. Error: %s' % (str (first_rev), 
                                                                             str (e))
                    raise ExtensionRunError (msg)
                
                printdbg ('SVN checkout first rev finished')
            
            # Obtain files and revisions
            query =  'SELECT rev, path, a.commit_id, a.file_id, composed_rev '
            query += 'FROM scmlog s, actions a, file_paths f '
            query += 'WHERE (a.type="M" or a.type="A") '
            query += 'AND a.commit_id=s.id '
            query += 'AND a.file_id=f.id '
            query += 'AND s.repository_id=?'

            current_revision = None
            read_cursor.execute (statement (query, db.place_holder), (repoid,))
            for revision, filepath, commit_id, file_id, composed in read_cursor.fetchall ():
                if composed:
                    revision = revision.split ("|")[0]
                    
                # Remove repository url from filepath
                # (all the filepaths begin with the repo URL)

                # Heuristics, depending on the repository
                relative_path = ""
                
                if type == 'svn':                    
                    try:
                        relative_path = filepath.split(uri)[1]
                    except IndexError:
                        relative_path = filepath
                        
                elif type == 'cvs':                    
                    try:
                        relative_path = filepath.split(uri)[1]
                    except IndexError:
                        relative_path = filepath

                    try:
                        relative_path = filepath.split(uri.split(":")[-1])[1]
                    except IndexError:
                        relative_path = filepath

                printdbg (repobj.get_uri ())
                printdbg (relative_path)

                if revision != current_revision:
                    try:
                        if repobj.get_type () == 'svn':
                            printdbg ("Updating tree to revision %s", (revision))
                            repobj.update (tmpdir, rev=revision, force=True)
                        else:
                            printdbg ("Checking out %s @ %s", (relative_path, revision))
                            repository.checkout (relative_path, tmpdir, rev=revision)
                    except Exception, e:
                        printerr ("Error obtaining %s@%s. Exception: %s", (relative_path, revision, str (e)))
            
                    current_revision = revision

                checkout_path = os.path.join (tmpdir, relative_path)
                fm = create_file_metrics (checkout_path)
                    
                # Measure the file
                printdbg ("Measuring %s @ %s", (checkout_path, revision))
                measures = Measures ()

                try:
                    measures.loc = fm.get_LOC ()
                except Exception, e:
                    printerr ('Error loc. Exception: %s', (str (e)))
            
                try:
                    measures.sloc, measures.lang = fm.get_SLOCLang ()
                except Exception, e:
                    printerr ('Error sloc. Exception: %s', (str (e)))

                try:
                    measures.ncomment, measures.lcomment, measures.lblank = fm.get_CommentsBlank ()
                except NotImplementedError:
                    pass
                except Exception, e:
                    printerr ('Error CommentsBlank. Exception: %s', (str (e)))

                try:
                    measures.halstead_length, measures.halstead_vol, \
                        measures.halstead_level, measures.halstead_md = fm.get_HalsteadComplexity ()
                except NotImplementedError:
                    pass
                except Exception, e:
                    printerr ('Error cmetrics halstead. Exception: %s', (str (e)))
                    
                try:
                    measures.mccabe_sum, measures.mccabe_min, measures.mccabe_max, \
                        measures.mccabe_mean, measures.mccabe_median, \
                        measures.nfunctions = fm.get_MccabeComplexity ()
                except NotImplementedError:
                    pass
                except Exception, e:
                    printerr ('Error cmetrics mccabe. Exception: %s', (str(e)))
                
                # Create SQL Query insert
                fields = ['file_id', 'commit_id']
                values = [file_id, commit_id]
                
                for key in measures.getattrs ():
                    fields.append (key)
                    values.append (getattr (measures, key))

                fields = ','.join (fields)
                
                query = 'INSERT INTO metrics '
                query += '(%s) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)' % (fields)
                write_cursor.execute (statement (query, db.place_holder), values)

            # Write everything related to this repo
            cnn.commit()
            # TODO: Clean tmpdir

        cnn.close()

register_extension ("Metrics", Metrics)
